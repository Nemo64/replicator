import {readFile, stat} from "fs/promises";
import {dirname, resolve} from "path";
import {performance} from "perf_hooks";

import {Mappings, parse} from "./config";
import {FilesystemSource} from "./drivers/filesystem_source";
import {FilesystemTarget} from "./drivers/filesystem_target";
import {JsonFormat} from "./drivers/json_format";
import {Environment, Initializer, Event} from "./drivers/types";
import {AsyncMergeIterator} from "./util/async_merge_iterator";
import {generateViews} from "./view";

// public api

export {Mapping, ViewMapping, Mappings} from "./config";
export * from "./drivers/types"; // so you can create your own drivers

/**
 * Parses a config file and loads the corresponding drivers.
 */
export async function parseConfiguration(configPath: string): Promise<Mappings> {
    configPath = resolve(configPath);

    const [config, stats] = await Promise.all([
        readFile(configPath, {encoding: 'utf8'}).then(JSON.parse),
        stat(configPath),
    ]);

    const environment: Environment = {
        workingDirectory: dirname(configPath),
        lastConfigChange: stats.mtime,
    };

    return await parse(config, environment);
}

/**
 * This method takes a configuration and allows to iterate {@see Event}'s.
 * These can then asynchronously be processed by {@see processEvent}.
 * You can even process the events in separate process if you like.
 */
export function watchForEvents(mappings: Mappings): AsyncIterable<Event> {
    const eventIterator = new AsyncMergeIterator<Event>();

    for (const {source} of mappings.values()) {
        eventIterator.add(source.watch());
    }

    return eventIterator;
}

/**
 * Processes an event generated by {@see watchForEvents} or by {@see Source.watch} directly.
 * You can also generate your own {@see Event}, if your environment requires this.
 */
export function processEvent(mappings: Mappings, event: Event): Promise<Update> {
    const mapping = mappings.get(event.sourceName);
    if (!mapping) {
        throw new Error(`there is no source named ${event.sourceName}`);
    }

    return mapping.source.process(event, async change => {
        const updates = [];
        const viewIds = [];
        const startTime = performance.now();

        for (const viewMapping of mapping.views) {
            for (const [viewId, entries] of generateViews(change, viewMapping)) {
                updates.push(viewMapping.target.update({viewId, event, entries}));
                viewIds.push(viewId);
            }
        }

        const processTime = performance.now() - startTime;
        await Promise.all(updates);
        const updateTime = performance.now() - startTime - processTime;

        return {...event, viewIds, processTime, updateTime};
    });
}

export interface Update extends Event {
    readonly viewIds: string[];
    readonly processTime: number;
    readonly updateTime: number;
}

/////////////
// drivers //
/////////////

/**
 * Initializes the filesystem driver.
 * You probably don't want to call this method directly.
 * @see loadDriver
 */
export const filesystem: Initializer = async (type, options, context) => {
    switch (type) {
        case "source":
            return await FilesystemSource.create(options, context);
        case "target":
            return await FilesystemTarget.create(options, context);
        default:
            throw new Error(`filesystem driver can't be used as ${type}.`);
    }
};

/**
 * Initializes the json driver.
 * You probably don't want to call this method directly.
 * @see loadDriver
 */
export const json: Initializer = async (type, options, context) => {
    switch (type) {
        case "source_format":
        case "target_format":
            return new JsonFormat(options, context);
        default:
            throw new Error(`json format can't be used as ${type}.`);
    }
};
